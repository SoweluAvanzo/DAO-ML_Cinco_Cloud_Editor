/******************************************************************************
 * This file was generated by langium-cli 2.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import type { AstNode, Reference, ReferenceInfo, TypeMetaData } from 'langium';
import { AbstractAstReflection } from 'langium';

export const CincoTerminals = {
    BOOL: /\b(true|false|TRUE|FALSE|True|False)\b/,
    STRING: /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,
    DOUBLE: /[0-9]*\.[0-9]+/,
    INT: /(-)?[0-9]+/,
    WS: /\s+/,
    QNAME: /(?!.*\.{2})[a-zA-Z]+\.[a-zA-Z]+(\.[a-zA-Z]+)*/,
    ID: /[_a-zA-Z][\w_]*/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};

export type AbstractPosition = AbsolutePosition | Alignment;

export const AbstractPosition = 'AbstractPosition';

export function isAbstractPosition(item: unknown): item is AbstractPosition {
    return reflection.isInstance(item, AbstractPosition);
}

export type AbstractShape = ContainerShape | Shape;

export const AbstractShape = 'AbstractShape';

export function isAbstractShape(item: unknown): item is AbstractShape {
    return reflection.isInstance(item, AbstractShape);
}

export type Attribute = ComplexAttribute | PrimitiveAttribute;

export const Attribute = 'Attribute';

export function isAttribute(item: unknown): item is Attribute {
    return reflection.isInstance(item, Attribute);
}

export type ComplexModelElement = Edge | GraphModel | NodeType | UserDefinedType;

export const ComplexModelElement = 'ComplexModelElement';

export function isComplexModelElement(item: unknown): item is ComplexModelElement {
    return reflection.isInstance(item, ComplexModelElement);
}

export type ContainerShape = Ellipse | Polygon | Rectangle | RoundedRectangle;

export const ContainerShape = 'ContainerShape';

export function isContainerShape(item: unknown): item is ContainerShape {
    return reflection.isInstance(item, ContainerShape);
}

export type CustomDataType = Edge | Enum | GraphModel | NodeType | UserDefinedType;

export const CustomDataType = 'CustomDataType';

export function isCustomDataType(item: unknown): item is CustomDataType {
    return reflection.isInstance(item, CustomDataType);
}

export type DataType = 'Date' | 'boolean' | 'number' | 'string';

export function isDataType(item: unknown): item is DataType {
    return item === 'string' || item === 'boolean' || item === 'number' || item === 'Date';
}

export type GraphicsAlgorithm = Ellipse | Image | MultiText | Polygon | Polyline | Text | WebView;

export const GraphicsAlgorithm = 'GraphicsAlgorithm';

export function isGraphicsAlgorithm(item: unknown): item is GraphicsAlgorithm {
    return reflection.isInstance(item, GraphicsAlgorithm);
}

export type ModelElement = ComplexModelElement | Enum;

export const ModelElement = 'ModelElement';

export function isModelElement(item: unknown): item is ModelElement {
    return reflection.isInstance(item, ModelElement);
}

export type ModelElementBaseTypes = 'Container' | 'Edge' | 'GraphModel' | 'ModelElement' | 'ModelElementContainer' | 'Node';

export function isModelElementBaseTypes(item: unknown): item is ModelElementBaseTypes {
    return item === 'GraphModel' || item === 'Node' || item === 'Edge' || item === 'Container' || item === 'ModelElement' || item === 'ModelElementContainer';
}

export type NodeType = Node | NodeContainer;

export const NodeType = 'NodeType';

export function isNodeType(item: unknown): item is NodeType {
    return reflection.isInstance(item, NodeType);
}

export type PrimitiveDefaultValue = number | string;

export type Shape = Image | MultiText | Polyline | Text | WebView;

export const Shape = 'Shape';

export function isShape(item: unknown): item is Shape {
    return reflection.isInstance(item, Shape);
}

export type Style = EdgeStyle | NodeStyle;

export const Style = 'Style';

export function isStyle(item: unknown): item is Style {
    return reflection.isInstance(item, Style);
}

export interface AbsolutePosition extends AstNode {
    readonly $container: Ellipse | Image | MultiText | Polygon | Rectangle | RoundedRectangle | Text | WebView;
    readonly $type: 'AbsolutePosition';
    xPos: number
    yPos: number
}

export const AbsolutePosition = 'AbsolutePosition';

export function isAbsolutePosition(item: unknown): item is AbsolutePosition {
    return reflection.isInstance(item, AbsolutePosition);
}

export interface Alignment extends AstNode {
    readonly $container: Ellipse | Image | MultiText | Polygon | Rectangle | RoundedRectangle | Text | WebView;
    readonly $type: 'Alignment';
    horizontal: HAlignment
    vertical: VAlignment
    xMargin?: number
    yMargin?: number
}

export const Alignment = 'Alignment';

export function isAlignment(item: unknown): item is Alignment {
    return reflection.isInstance(item, Alignment);
}

export interface Annotation extends AstNode {
    readonly $container: ComplexAttribute | Edge | Enum | GraphModel | MglModel | Node | NodeContainer | PrimitiveAttribute | ReferencedEClass | ReferencedModelElement | UserDefinedType;
    readonly $type: 'Annotation';
    name: string
    value: Array<string>
}

export const Annotation = 'Annotation';

export function isAnnotation(item: unknown): item is Annotation {
    return reflection.isInstance(item, Annotation);
}

export interface Appearance extends AstNode {
    readonly $container: Styles;
    readonly $type: 'Appearance';
    background?: Color
    filled?: Boolean
    font?: Font
    foreground?: Color
    imagePath?: string
    lineStyle?: LineStyle
    lineWidth?: number
    name: string
    parent?: Reference<Appearance>
    transparency?: number
}

export const Appearance = 'Appearance';

export function isAppearance(item: unknown): item is Appearance {
    return reflection.isInstance(item, Appearance);
}

export interface Boolean extends AstNode {
    readonly $container: Appearance | InlineAppearance | WebView;
    readonly $type: 'Boolean';
    value: 'false' | 'true'
}

export const Boolean = 'Boolean';

export function isBoolean(item: unknown): item is Boolean {
    return reflection.isInstance(item, Boolean);
}

export interface Color extends AstNode {
    readonly $container: Appearance | InlineAppearance;
    readonly $type: 'Color';
    b: number
    g: number
    r: number
}

export const Color = 'Color';

export function isColor(item: unknown): item is Color {
    return reflection.isInstance(item, Color);
}

export interface ComplexAttribute extends AstNode {
    readonly $container: Edge | GraphModel | Node | NodeContainer | UserDefinedType;
    readonly $type: 'ComplexAttribute';
    annotations: Array<Annotation>
    defaultValue?: string
    lowerBound?: number
    name: string
    notChangeable: boolean
    override: boolean
    type: Reference<CustomDataType>
    unique: boolean
    upperBound?: '*' | number
}

export const ComplexAttribute = 'ComplexAttribute';

export function isComplexAttribute(item: unknown): item is ComplexAttribute {
    return reflection.isInstance(item, ComplexAttribute);
}

export interface ConnectionDecorator extends AstNode {
    readonly $container: EdgeStyle;
    readonly $type: 'ConnectionDecorator';
    decoratorShape?: GraphicsAlgorithm
    location: number
    movable: boolean
    name?: string
    predefinedDecorator?: PredefinedDecorator
}

export const ConnectionDecorator = 'ConnectionDecorator';

export function isConnectionDecorator(item: unknown): item is ConnectionDecorator {
    return reflection.isInstance(item, ConnectionDecorator);
}

export interface ConnectionType extends AstNode {
    readonly $container: EdgeStyle;
    readonly $type: 'ConnectionType';
    FreeForm: 'freeform'
}

export const ConnectionType = 'ConnectionType';

export function isConnectionType(item: unknown): item is ConnectionType {
    return reflection.isInstance(item, ConnectionType);
}

export interface DecoratorShape extends AstNode {
    readonly $container: PredefinedDecorator;
    readonly $type: 'DecoratorShape';
    shapeType: 'ARROW' | 'CIRCLE' | 'DIAMOND' | 'TRIANGLE'
}

export const DecoratorShape = 'DecoratorShape';

export function isDecoratorShape(item: unknown): item is DecoratorShape {
    return reflection.isInstance(item, DecoratorShape);
}

export interface DefaultValueOverride extends AstNode {
    readonly $container: Edge | GraphModel | Node | NodeContainer | UserDefinedType;
    readonly $type: 'DefaultValueOverride';
    attribute: string
    defaultValue?: PrimitiveDefaultValue
}

export const DefaultValueOverride = 'DefaultValueOverride';

export function isDefaultValueOverride(item: unknown): item is DefaultValueOverride {
    return reflection.isInstance(item, DefaultValueOverride);
}

export interface Edge extends AstNode {
    readonly $container: MglModel;
    readonly $type: 'Edge';
    annotations: Array<Annotation>
    attributes: Array<Attribute>
    defaultValueOverrides: Array<DefaultValueOverride>
    externalExtension?: ExternalReference
    isAbstract: boolean
    localExtension?: Reference<Edge>
    name: string
    styleParameters: Array<string>
    usedStyle?: string
}

export const Edge = 'Edge';

export function isEdge(item: unknown): item is Edge {
    return reflection.isInstance(item, Edge);
}

export interface EdgeElementConnection extends AstNode {
    readonly $container: Node | NodeContainer;
    readonly $type: 'EdgeElementConnection';
    externalConnection?: ExternalReference
    localConnection: Array<Reference<Edge>>
    lowerBound?: number
    upperBound?: '*' | number
}

export const EdgeElementConnection = 'EdgeElementConnection';

export function isEdgeElementConnection(item: unknown): item is EdgeElementConnection {
    return reflection.isInstance(item, EdgeElementConnection);
}

export interface EdgeStyle extends AstNode {
    readonly $container: Styles;
    readonly $type: 'EdgeStyle';
    appearanceProvider?: string
    connectionType?: ConnectionType
    decorator: Array<ConnectionDecorator>
    inlineAppearance?: InlineAppearance
    name: string
    parameterCount?: number
    referencedAppearance?: Reference<Appearance>
}

export const EdgeStyle = 'EdgeStyle';

export function isEdgeStyle(item: unknown): item is EdgeStyle {
    return reflection.isInstance(item, EdgeStyle);
}

export interface Ellipse extends AstNode {
    readonly $container: ConnectionDecorator | Ellipse | NodeStyle | Polygon | Rectangle | RoundedRectangle;
    readonly $type: 'Ellipse';
    anchorShape: boolean
    children: Array<AbstractShape>
    inlineAppearance?: InlineAppearance
    name?: string
    position?: AbstractPosition
    referencedAppearance?: Reference<Appearance>
    size?: Size
}

export const Ellipse = 'Ellipse';

export function isEllipse(item: unknown): item is Ellipse {
    return reflection.isInstance(item, Ellipse);
}

export interface Enum extends AstNode {
    readonly $container: MglModel;
    readonly $type: 'Enum';
    annotations: Array<Annotation>
    literals: Array<string>
    name: string
}

export const Enum = 'Enum';

export function isEnum(item: unknown): item is Enum {
    return reflection.isInstance(item, Enum);
}

export interface ExternalReference extends AstNode {
    readonly $container: Edge | EdgeElementConnection | GraphModel | GraphicalElementContainment | Node | NodeContainer | UserDefinedType;
    readonly $type: 'ExternalReference';
    elements: Array<string>
    import: Reference<Import>
}

export const ExternalReference = 'ExternalReference';

export function isExternalReference(item: unknown): item is ExternalReference {
    return reflection.isInstance(item, ExternalReference);
}

export interface Font extends AstNode {
    readonly $container: Appearance | InlineAppearance;
    readonly $type: 'Font';
    fontName: string
    isBold: boolean
    isItalic: boolean
    size: number
}

export const Font = 'Font';

export function isFont(item: unknown): item is Font {
    return reflection.isInstance(item, Font);
}

export interface GraphicalElementContainment extends AstNode {
    readonly $container: GraphModel | NodeContainer;
    readonly $type: 'GraphicalElementContainment';
    externalContainment?: ExternalReference
    localContainments: Array<Reference<NodeType>>
    lowerBound?: number
    upperBound?: '*' | number
}

export const GraphicalElementContainment = 'GraphicalElementContainment';

export function isGraphicalElementContainment(item: unknown): item is GraphicalElementContainment {
    return reflection.isInstance(item, GraphicalElementContainment);
}

export interface GraphModel extends AstNode {
    readonly $container: MglModel;
    readonly $type: 'GraphModel';
    annotations: Array<Annotation>
    attributes: Array<Attribute>
    containableElements: Array<GraphicalElementContainment>
    containmentWildcards: Array<Wildcard>
    defaultValueOverrides: Array<DefaultValueOverride>
    externalExtension?: ExternalReference
    fileExtension?: string
    iconPath?: string
    isAbstract: boolean
    localExtension?: Reference<GraphModel>
    name: string
}

export const GraphModel = 'GraphModel';

export function isGraphModel(item: unknown): item is GraphModel {
    return reflection.isInstance(item, GraphModel);
}

export interface HAlignment extends AstNode {
    readonly $container: Alignment;
    readonly $type: 'HAlignment';
    alignmentType: 'CENTER' | 'LEFT' | 'RIGHT'
}

export const HAlignment = 'HAlignment';

export function isHAlignment(item: unknown): item is HAlignment {
    return reflection.isInstance(item, HAlignment);
}

export interface Image extends AstNode {
    readonly $container: ConnectionDecorator | Ellipse | NodeStyle | Polygon | Rectangle | RoundedRectangle;
    readonly $type: 'Image';
    anchorShape: boolean
    name?: string
    path: string
    position?: AbstractPosition
    size: Size
}

export const Image = 'Image';

export function isImage(item: unknown): item is Image {
    return reflection.isInstance(item, Image);
}

export interface Import extends AstNode {
    readonly $container: MglModel;
    readonly $type: 'Import';
    external: boolean
    importURI: string
    name: string
    stealth: boolean
}

export const Import = 'Import';

export function isImport(item: unknown): item is Import {
    return reflection.isInstance(item, Import);
}

export interface InlineAppearance extends AstNode {
    readonly $container: EdgeStyle | Ellipse | MultiText | Polygon | Polyline | PredefinedDecorator | Rectangle | RoundedRectangle | Text;
    readonly $type: 'InlineAppearance';
    background?: Color
    filled?: Boolean
    font?: Font
    foreground?: Color
    imagePath?: string
    lineStyle?: LineStyle
    lineWidth?: number
    parent?: Reference<Appearance>
    transparency?: number
}

export const InlineAppearance = 'InlineAppearance';

export function isInlineAppearance(item: unknown): item is InlineAppearance {
    return reflection.isInstance(item, InlineAppearance);
}

export interface LineStyle extends AstNode {
    readonly $container: Appearance | InlineAppearance;
    readonly $type: 'LineStyle';
    lineType: 'DASH' | 'DASHDOT' | 'DASHDOTDOT' | 'DOT' | 'SOLID'
}

export const LineStyle = 'LineStyle';

export function isLineStyle(item: unknown): item is LineStyle {
    return reflection.isInstance(item, LineStyle);
}

export interface MglModel extends AstNode {
    readonly $type: 'MglModel';
    annotations: Array<Annotation>
    imports: Array<Import>
    includeResources: Array<string>
    modelElements: Array<ModelElement>
    package?: string
    stylePath: string
}

export const MglModel = 'MglModel';

export function isMglModel(item: unknown): item is MglModel {
    return reflection.isInstance(item, MglModel);
}

export interface MultiText extends AstNode {
    readonly $container: ConnectionDecorator | Ellipse | NodeStyle | Polygon | Rectangle | RoundedRectangle;
    readonly $type: 'MultiText';
    anchorShape: boolean
    inlineAppearance?: InlineAppearance
    name?: string
    position?: AbstractPosition
    referencedAppearance?: Reference<Appearance>
    value: string
}

export const MultiText = 'MultiText';

export function isMultiText(item: unknown): item is MultiText {
    return reflection.isInstance(item, MultiText);
}

export interface Node extends AstNode {
    readonly $container: MglModel;
    readonly $type: 'Node';
    annotations: Array<Annotation>
    attributes: Array<Attribute>
    defaultValueOverrides: Array<DefaultValueOverride>
    externalExtension?: ExternalReference
    incomingEdgeConnections: Array<EdgeElementConnection>
    incomingWildcards: Array<Wildcard>
    isAbstract: boolean
    localExtension?: Reference<Node>
    name: string
    outgoingEdgeConnections: Array<EdgeElementConnection>
    outgoingWildcards: Array<Wildcard>
    primeReference?: ReferencedEClass | ReferencedModelElement
    styleParameters: Array<string>
    usedStyle?: string
}

export const Node = 'Node';

export function isNode(item: unknown): item is Node {
    return reflection.isInstance(item, Node);
}

export interface NodeContainer extends AstNode {
    readonly $container: MglModel;
    readonly $type: 'NodeContainer';
    annotations: Array<Annotation>
    attributes: Array<Attribute>
    containableElements: Array<GraphicalElementContainment>
    containmentWildcards: Array<Wildcard>
    defaultValueOverrides: Array<DefaultValueOverride>
    externalExtension?: ExternalReference
    incomingEdgeConnections: Array<EdgeElementConnection>
    incomingWildcards: Array<Wildcard>
    isAbstract: boolean
    localExtension?: Reference<NodeType>
    name: string
    outgoingEdgeConnections: Array<EdgeElementConnection>
    outgoingWildcards: Array<Wildcard>
    primeReference?: ReferencedEClass | ReferencedModelElement
    styleParameters: Array<string>
    usedStyle?: string
}

export const NodeContainer = 'NodeContainer';

export function isNodeContainer(item: unknown): item is NodeContainer {
    return reflection.isInstance(item, NodeContainer);
}

export interface NodeStyle extends AstNode {
    readonly $container: Styles;
    readonly $type: 'NodeStyle';
    appearanceProvider?: string
    fixed: boolean
    mainShape: AbstractShape
    name: string
    parameterCount?: number
}

export const NodeStyle = 'NodeStyle';

export function isNodeStyle(item: unknown): item is NodeStyle {
    return reflection.isInstance(item, NodeStyle);
}

export interface Point extends AstNode {
    readonly $container: Polygon | Polyline;
    readonly $type: 'Point';
    x: number
    y: number
}

export const Point = 'Point';

export function isPoint(item: unknown): item is Point {
    return reflection.isInstance(item, Point);
}

export interface Polygon extends AstNode {
    readonly $container: ConnectionDecorator | Ellipse | NodeStyle | Polygon | Rectangle | RoundedRectangle;
    readonly $type: 'Polygon';
    anchorShape: boolean
    children: Array<AbstractShape>
    inlineAppearance?: InlineAppearance
    name?: string
    points: Array<Point>
    position?: AbstractPosition
    referencedAppearance?: Reference<Appearance>
    size?: Size
}

export const Polygon = 'Polygon';

export function isPolygon(item: unknown): item is Polygon {
    return reflection.isInstance(item, Polygon);
}

export interface Polyline extends AstNode {
    readonly $container: ConnectionDecorator | Ellipse | NodeStyle | Polygon | Rectangle | RoundedRectangle;
    readonly $type: 'Polyline';
    anchorShape: boolean
    inlineAppearance?: InlineAppearance
    name?: string
    points: Array<Point>
    referencedAppearance?: Reference<Appearance>
    size?: Size
}

export const Polyline = 'Polyline';

export function isPolyline(item: unknown): item is Polyline {
    return reflection.isInstance(item, Polyline);
}

export interface PredefinedDecorator extends AstNode {
    readonly $container: ConnectionDecorator;
    readonly $type: 'PredefinedDecorator';
    inlineAppearance?: InlineAppearance
    referencedAppearance?: Reference<Appearance>
    shape: DecoratorShape
}

export const PredefinedDecorator = 'PredefinedDecorator';

export function isPredefinedDecorator(item: unknown): item is PredefinedDecorator {
    return reflection.isInstance(item, PredefinedDecorator);
}

export interface PrimitiveAttribute extends AstNode {
    readonly $container: Edge | GraphModel | Node | NodeContainer | UserDefinedType;
    readonly $type: 'PrimitiveAttribute';
    annotations: Array<Annotation>
    dataType: DataType
    defaultValue?: PrimitiveDefaultValue
    lowerBound?: number
    name: string
    notChangeable: boolean
    unique: boolean
    upperBound?: '*' | number
}

export const PrimitiveAttribute = 'PrimitiveAttribute';

export function isPrimitiveAttribute(item: unknown): item is PrimitiveAttribute {
    return reflection.isInstance(item, PrimitiveAttribute);
}

export interface Rectangle extends AstNode {
    readonly $container: Ellipse | NodeStyle | Polygon | Rectangle | RoundedRectangle;
    readonly $type: 'Rectangle';
    anchorShape: boolean
    children: Array<AbstractShape>
    inlineAppearance?: InlineAppearance
    name?: string
    position?: AbstractPosition
    referencedAppearance?: Reference<Appearance>
    size?: Size
}

export const Rectangle = 'Rectangle';

export function isRectangle(item: unknown): item is Rectangle {
    return reflection.isInstance(item, Rectangle);
}

export interface ReferencedEClass extends AstNode {
    readonly $container: Node | NodeContainer;
    readonly $type: 'ReferencedEClass';
    annotations: Array<Annotation>
    copiedAttributes: Array<ReferencedEStructuralFeature>
    eClass: string
    import: Reference<Import>
    name: string
}

export const ReferencedEClass = 'ReferencedEClass';

export function isReferencedEClass(item: unknown): item is ReferencedEClass {
    return reflection.isInstance(item, ReferencedEClass);
}

export interface ReferencedEStructuralFeature extends AstNode {
    readonly $container: ReferencedEClass;
    readonly $type: 'ReferencedEStructuralFeature';
    feature: string
    name: string
    parameter: boolean
}

export const ReferencedEStructuralFeature = 'ReferencedEStructuralFeature';

export function isReferencedEStructuralFeature(item: unknown): item is ReferencedEStructuralFeature {
    return reflection.isInstance(item, ReferencedEStructuralFeature);
}

export interface ReferencedMGLAttribute extends AstNode {
    readonly $container: ReferencedModelElement;
    readonly $type: 'ReferencedMGLAttribute';
    feature: Reference<Attribute>
    name: string
}

export const ReferencedMGLAttribute = 'ReferencedMGLAttribute';

export function isReferencedMGLAttribute(item: unknown): item is ReferencedMGLAttribute {
    return reflection.isInstance(item, ReferencedMGLAttribute);
}

export interface ReferencedModelElement extends AstNode {
    readonly $container: Node | NodeContainer;
    readonly $type: 'ReferencedModelElement';
    annotations: Array<Annotation>
    copiedAttributes: Array<ReferencedMGLAttribute>
    import?: Reference<Import>
    modelElement?: Reference<ModelElement>
    modelElementBaseType?: ModelElementBaseTypes
    name: string
    referencedModelElement?: string
}

export const ReferencedModelElement = 'ReferencedModelElement';

export function isReferencedModelElement(item: unknown): item is ReferencedModelElement {
    return reflection.isInstance(item, ReferencedModelElement);
}

export interface RoundedRectangle extends AstNode {
    readonly $container: Ellipse | NodeStyle | Polygon | Rectangle | RoundedRectangle;
    readonly $type: 'RoundedRectangle';
    anchorShape: boolean
    children: Array<AbstractShape>
    cornerHeight: number
    cornerWidth: number
    inlineAppearance?: InlineAppearance
    name?: string
    position?: AbstractPosition
    referencedAppearance?: Reference<Appearance>
    size: Size
}

export const RoundedRectangle = 'RoundedRectangle';

export function isRoundedRectangle(item: unknown): item is RoundedRectangle {
    return reflection.isInstance(item, RoundedRectangle);
}

export interface Size extends AstNode {
    readonly $container: Ellipse | Image | Polygon | Polyline | Rectangle | RoundedRectangle | WebView;
    readonly $type: 'Size';
    height: number
    heightFixed: boolean
    width: number
    widthFixed: boolean
}

export const Size = 'Size';

export function isSize(item: unknown): item is Size {
    return reflection.isInstance(item, Size);
}

export interface Styles extends AstNode {
    readonly $type: 'Styles';
    appearances: Array<Appearance>
    styles: Array<Style>
}

export const Styles = 'Styles';

export function isStyles(item: unknown): item is Styles {
    return reflection.isInstance(item, Styles);
}

export interface Text extends AstNode {
    readonly $container: ConnectionDecorator | Ellipse | NodeStyle | Polygon | Rectangle | RoundedRectangle;
    readonly $type: 'Text';
    anchorShape: boolean
    inlineAppearance?: InlineAppearance
    name?: string
    position?: AbstractPosition
    referencedAppearance?: Reference<Appearance>
    value?: string
}

export const Text = 'Text';

export function isText(item: unknown): item is Text {
    return reflection.isInstance(item, Text);
}

export interface UserDefinedType extends AstNode {
    readonly $container: MglModel;
    readonly $type: 'UserDefinedType';
    annotations: Array<Annotation>
    attributes: Array<Attribute>
    defaultValueOverrides: Array<DefaultValueOverride>
    externalExtension?: ExternalReference
    isAbstract: boolean
    localExtension?: Reference<UserDefinedType>
    name: string
}

export const UserDefinedType = 'UserDefinedType';

export function isUserDefinedType(item: unknown): item is UserDefinedType {
    return reflection.isInstance(item, UserDefinedType);
}

export interface VAlignment extends AstNode {
    readonly $container: Alignment;
    readonly $type: 'VAlignment';
    alignmentType: 'BOTTOM' | 'MIDDLE' | 'TOP'
}

export const VAlignment = 'VAlignment';

export function isVAlignment(item: unknown): item is VAlignment {
    return reflection.isInstance(item, VAlignment);
}

export interface WebView extends AstNode {
    readonly $container: ConnectionDecorator | Ellipse | NodeStyle | Polygon | Rectangle | RoundedRectangle;
    readonly $type: 'WebView';
    anchorShape: boolean
    content: string
    name?: string
    padding?: number
    position?: AbstractPosition
    scrollable?: Boolean
    size?: Size
}

export const WebView = 'WebView';

export function isWebView(item: unknown): item is WebView {
    return reflection.isInstance(item, WebView);
}

export interface Wildcard extends AstNode {
    readonly $container: GraphModel | Node | NodeContainer;
    readonly $type: 'Wildcard';
    lowerBound?: number
    referencedImport?: Reference<Import>
    selfWildcard: boolean
    upperBound?: '*' | number
}

export const Wildcard = 'Wildcard';

export function isWildcard(item: unknown): item is Wildcard {
    return reflection.isInstance(item, Wildcard);
}

export type CincoAstType = {
    AbsolutePosition: AbsolutePosition
    AbstractPosition: AbstractPosition
    AbstractShape: AbstractShape
    Alignment: Alignment
    Annotation: Annotation
    Appearance: Appearance
    Attribute: Attribute
    Boolean: Boolean
    Color: Color
    ComplexAttribute: ComplexAttribute
    ComplexModelElement: ComplexModelElement
    ConnectionDecorator: ConnectionDecorator
    ConnectionType: ConnectionType
    ContainerShape: ContainerShape
    CustomDataType: CustomDataType
    DecoratorShape: DecoratorShape
    DefaultValueOverride: DefaultValueOverride
    Edge: Edge
    EdgeElementConnection: EdgeElementConnection
    EdgeStyle: EdgeStyle
    Ellipse: Ellipse
    Enum: Enum
    ExternalReference: ExternalReference
    Font: Font
    GraphModel: GraphModel
    GraphicalElementContainment: GraphicalElementContainment
    GraphicsAlgorithm: GraphicsAlgorithm
    HAlignment: HAlignment
    Image: Image
    Import: Import
    InlineAppearance: InlineAppearance
    LineStyle: LineStyle
    MglModel: MglModel
    ModelElement: ModelElement
    MultiText: MultiText
    Node: Node
    NodeContainer: NodeContainer
    NodeStyle: NodeStyle
    NodeType: NodeType
    Point: Point
    Polygon: Polygon
    Polyline: Polyline
    PredefinedDecorator: PredefinedDecorator
    PrimitiveAttribute: PrimitiveAttribute
    Rectangle: Rectangle
    ReferencedEClass: ReferencedEClass
    ReferencedEStructuralFeature: ReferencedEStructuralFeature
    ReferencedMGLAttribute: ReferencedMGLAttribute
    ReferencedModelElement: ReferencedModelElement
    RoundedRectangle: RoundedRectangle
    Shape: Shape
    Size: Size
    Style: Style
    Styles: Styles
    Text: Text
    UserDefinedType: UserDefinedType
    VAlignment: VAlignment
    WebView: WebView
    Wildcard: Wildcard
}

export class CincoAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['AbsolutePosition', 'AbstractPosition', 'AbstractShape', 'Alignment', 'Annotation', 'Appearance', 'Attribute', 'Boolean', 'Color', 'ComplexAttribute', 'ComplexModelElement', 'ConnectionDecorator', 'ConnectionType', 'ContainerShape', 'CustomDataType', 'DecoratorShape', 'DefaultValueOverride', 'Edge', 'EdgeElementConnection', 'EdgeStyle', 'Ellipse', 'Enum', 'ExternalReference', 'Font', 'GraphModel', 'GraphicalElementContainment', 'GraphicsAlgorithm', 'HAlignment', 'Image', 'Import', 'InlineAppearance', 'LineStyle', 'MglModel', 'ModelElement', 'MultiText', 'Node', 'NodeContainer', 'NodeStyle', 'NodeType', 'Point', 'Polygon', 'Polyline', 'PredefinedDecorator', 'PrimitiveAttribute', 'Rectangle', 'ReferencedEClass', 'ReferencedEStructuralFeature', 'ReferencedMGLAttribute', 'ReferencedModelElement', 'RoundedRectangle', 'Shape', 'Size', 'Style', 'Styles', 'Text', 'UserDefinedType', 'VAlignment', 'WebView', 'Wildcard'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case AbsolutePosition:
            case Alignment: {
                return this.isSubtype(AbstractPosition, supertype);
            }
            case ComplexAttribute:
            case PrimitiveAttribute: {
                return this.isSubtype(Attribute, supertype);
            }
            case ComplexModelElement: {
                return this.isSubtype(ModelElement, supertype);
            }
            case ContainerShape:
            case Shape: {
                return this.isSubtype(AbstractShape, supertype);
            }
            case Edge:
            case GraphModel:
            case NodeType:
            case UserDefinedType: {
                return this.isSubtype(ComplexModelElement, supertype) || this.isSubtype(CustomDataType, supertype);
            }
            case EdgeStyle:
            case NodeStyle: {
                return this.isSubtype(Style, supertype);
            }
            case Ellipse:
            case Polygon: {
                return this.isSubtype(ContainerShape, supertype) || this.isSubtype(GraphicsAlgorithm, supertype);
            }
            case Enum: {
                return this.isSubtype(CustomDataType, supertype) || this.isSubtype(ModelElement, supertype);
            }
            case Image:
            case MultiText:
            case Polyline:
            case Text:
            case WebView: {
                return this.isSubtype(GraphicsAlgorithm, supertype) || this.isSubtype(Shape, supertype);
            }
            case Node:
            case NodeContainer: {
                return this.isSubtype(NodeType, supertype);
            }
            case Rectangle:
            case RoundedRectangle: {
                return this.isSubtype(ContainerShape, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Appearance:parent':
            case 'EdgeStyle:referencedAppearance':
            case 'Ellipse:referencedAppearance':
            case 'InlineAppearance:parent':
            case 'MultiText:referencedAppearance':
            case 'Polygon:referencedAppearance':
            case 'Polyline:referencedAppearance':
            case 'PredefinedDecorator:referencedAppearance':
            case 'Rectangle:referencedAppearance':
            case 'RoundedRectangle:referencedAppearance':
            case 'Text:referencedAppearance': {
                return Appearance;
            }
            case 'ComplexAttribute:type': {
                return CustomDataType;
            }
            case 'Edge:localExtension':
            case 'EdgeElementConnection:localConnection': {
                return Edge;
            }
            case 'ExternalReference:import':
            case 'ReferencedEClass:import':
            case 'ReferencedModelElement:import':
            case 'Wildcard:referencedImport': {
                return Import;
            }
            case 'GraphicalElementContainment:localContainments':
            case 'NodeContainer:localExtension': {
                return NodeType;
            }
            case 'GraphModel:localExtension': {
                return GraphModel;
            }
            case 'Node:localExtension': {
                return Node;
            }
            case 'ReferencedMGLAttribute:feature': {
                return Attribute;
            }
            case 'ReferencedModelElement:modelElement': {
                return ModelElement;
            }
            case 'UserDefinedType:localExtension': {
                return UserDefinedType;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'Annotation': {
                return {
                    name: 'Annotation',
                    mandatory: [
                        { name: 'value', type: 'array' }
                    ]
                };
            }
            case 'ComplexAttribute': {
                return {
                    name: 'ComplexAttribute',
                    mandatory: [
                        { name: 'annotations', type: 'array' },
                        { name: 'notChangeable', type: 'boolean' },
                        { name: 'override', type: 'boolean' },
                        { name: 'unique', type: 'boolean' }
                    ]
                };
            }
            case 'ConnectionDecorator': {
                return {
                    name: 'ConnectionDecorator',
                    mandatory: [
                        { name: 'movable', type: 'boolean' }
                    ]
                };
            }
            case 'Edge': {
                return {
                    name: 'Edge',
                    mandatory: [
                        { name: 'annotations', type: 'array' },
                        { name: 'attributes', type: 'array' },
                        { name: 'defaultValueOverrides', type: 'array' },
                        { name: 'isAbstract', type: 'boolean' },
                        { name: 'styleParameters', type: 'array' }
                    ]
                };
            }
            case 'EdgeElementConnection': {
                return {
                    name: 'EdgeElementConnection',
                    mandatory: [
                        { name: 'localConnection', type: 'array' }
                    ]
                };
            }
            case 'EdgeStyle': {
                return {
                    name: 'EdgeStyle',
                    mandatory: [
                        { name: 'decorator', type: 'array' }
                    ]
                };
            }
            case 'Ellipse': {
                return {
                    name: 'Ellipse',
                    mandatory: [
                        { name: 'anchorShape', type: 'boolean' },
                        { name: 'children', type: 'array' }
                    ]
                };
            }
            case 'Enum': {
                return {
                    name: 'Enum',
                    mandatory: [
                        { name: 'annotations', type: 'array' },
                        { name: 'literals', type: 'array' }
                    ]
                };
            }
            case 'ExternalReference': {
                return {
                    name: 'ExternalReference',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'Font': {
                return {
                    name: 'Font',
                    mandatory: [
                        { name: 'isBold', type: 'boolean' },
                        { name: 'isItalic', type: 'boolean' }
                    ]
                };
            }
            case 'GraphicalElementContainment': {
                return {
                    name: 'GraphicalElementContainment',
                    mandatory: [
                        { name: 'localContainments', type: 'array' }
                    ]
                };
            }
            case 'GraphModel': {
                return {
                    name: 'GraphModel',
                    mandatory: [
                        { name: 'annotations', type: 'array' },
                        { name: 'attributes', type: 'array' },
                        { name: 'containableElements', type: 'array' },
                        { name: 'containmentWildcards', type: 'array' },
                        { name: 'defaultValueOverrides', type: 'array' },
                        { name: 'isAbstract', type: 'boolean' }
                    ]
                };
            }
            case 'Image': {
                return {
                    name: 'Image',
                    mandatory: [
                        { name: 'anchorShape', type: 'boolean' }
                    ]
                };
            }
            case 'Import': {
                return {
                    name: 'Import',
                    mandatory: [
                        { name: 'external', type: 'boolean' },
                        { name: 'stealth', type: 'boolean' }
                    ]
                };
            }
            case 'MglModel': {
                return {
                    name: 'MglModel',
                    mandatory: [
                        { name: 'annotations', type: 'array' },
                        { name: 'imports', type: 'array' },
                        { name: 'includeResources', type: 'array' },
                        { name: 'modelElements', type: 'array' }
                    ]
                };
            }
            case 'MultiText': {
                return {
                    name: 'MultiText',
                    mandatory: [
                        { name: 'anchorShape', type: 'boolean' }
                    ]
                };
            }
            case 'Node': {
                return {
                    name: 'Node',
                    mandatory: [
                        { name: 'annotations', type: 'array' },
                        { name: 'attributes', type: 'array' },
                        { name: 'defaultValueOverrides', type: 'array' },
                        { name: 'incomingEdgeConnections', type: 'array' },
                        { name: 'incomingWildcards', type: 'array' },
                        { name: 'isAbstract', type: 'boolean' },
                        { name: 'outgoingEdgeConnections', type: 'array' },
                        { name: 'outgoingWildcards', type: 'array' },
                        { name: 'styleParameters', type: 'array' }
                    ]
                };
            }
            case 'NodeContainer': {
                return {
                    name: 'NodeContainer',
                    mandatory: [
                        { name: 'annotations', type: 'array' },
                        { name: 'attributes', type: 'array' },
                        { name: 'containableElements', type: 'array' },
                        { name: 'containmentWildcards', type: 'array' },
                        { name: 'defaultValueOverrides', type: 'array' },
                        { name: 'incomingEdgeConnections', type: 'array' },
                        { name: 'incomingWildcards', type: 'array' },
                        { name: 'isAbstract', type: 'boolean' },
                        { name: 'outgoingEdgeConnections', type: 'array' },
                        { name: 'outgoingWildcards', type: 'array' },
                        { name: 'styleParameters', type: 'array' }
                    ]
                };
            }
            case 'NodeStyle': {
                return {
                    name: 'NodeStyle',
                    mandatory: [
                        { name: 'fixed', type: 'boolean' }
                    ]
                };
            }
            case 'Polygon': {
                return {
                    name: 'Polygon',
                    mandatory: [
                        { name: 'anchorShape', type: 'boolean' },
                        { name: 'children', type: 'array' },
                        { name: 'points', type: 'array' }
                    ]
                };
            }
            case 'Polyline': {
                return {
                    name: 'Polyline',
                    mandatory: [
                        { name: 'anchorShape', type: 'boolean' },
                        { name: 'points', type: 'array' }
                    ]
                };
            }
            case 'PrimitiveAttribute': {
                return {
                    name: 'PrimitiveAttribute',
                    mandatory: [
                        { name: 'annotations', type: 'array' },
                        { name: 'notChangeable', type: 'boolean' },
                        { name: 'unique', type: 'boolean' }
                    ]
                };
            }
            case 'Rectangle': {
                return {
                    name: 'Rectangle',
                    mandatory: [
                        { name: 'anchorShape', type: 'boolean' },
                        { name: 'children', type: 'array' }
                    ]
                };
            }
            case 'ReferencedEClass': {
                return {
                    name: 'ReferencedEClass',
                    mandatory: [
                        { name: 'annotations', type: 'array' },
                        { name: 'copiedAttributes', type: 'array' }
                    ]
                };
            }
            case 'ReferencedEStructuralFeature': {
                return {
                    name: 'ReferencedEStructuralFeature',
                    mandatory: [
                        { name: 'parameter', type: 'boolean' }
                    ]
                };
            }
            case 'ReferencedModelElement': {
                return {
                    name: 'ReferencedModelElement',
                    mandatory: [
                        { name: 'annotations', type: 'array' },
                        { name: 'copiedAttributes', type: 'array' }
                    ]
                };
            }
            case 'RoundedRectangle': {
                return {
                    name: 'RoundedRectangle',
                    mandatory: [
                        { name: 'anchorShape', type: 'boolean' },
                        { name: 'children', type: 'array' }
                    ]
                };
            }
            case 'Size': {
                return {
                    name: 'Size',
                    mandatory: [
                        { name: 'heightFixed', type: 'boolean' },
                        { name: 'widthFixed', type: 'boolean' }
                    ]
                };
            }
            case 'Styles': {
                return {
                    name: 'Styles',
                    mandatory: [
                        { name: 'appearances', type: 'array' },
                        { name: 'styles', type: 'array' }
                    ]
                };
            }
            case 'Text': {
                return {
                    name: 'Text',
                    mandatory: [
                        { name: 'anchorShape', type: 'boolean' }
                    ]
                };
            }
            case 'UserDefinedType': {
                return {
                    name: 'UserDefinedType',
                    mandatory: [
                        { name: 'annotations', type: 'array' },
                        { name: 'attributes', type: 'array' },
                        { name: 'defaultValueOverrides', type: 'array' },
                        { name: 'isAbstract', type: 'boolean' }
                    ]
                };
            }
            case 'WebView': {
                return {
                    name: 'WebView',
                    mandatory: [
                        { name: 'anchorShape', type: 'boolean' }
                    ]
                };
            }
            case 'Wildcard': {
                return {
                    name: 'Wildcard',
                    mandatory: [
                        { name: 'selfWildcard', type: 'boolean' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new CincoAstReflection();
